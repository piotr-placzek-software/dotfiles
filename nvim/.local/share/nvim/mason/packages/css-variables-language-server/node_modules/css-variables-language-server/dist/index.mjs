// src/index.ts
import {
  createConnection,
  TextDocuments,
  ProposedFeatures,
  DidChangeConfigurationNotification,
  CompletionItemKind,
  TextDocumentSyncKind,
  FileChangeType
} from "vscode-languageserver/node";
import * as fs2 from "fs";
import { TextDocument } from "vscode-languageserver-textdocument";

// src/utils/isColor.ts
import * as culori from "culori";
var isColor = (str) => {
  const colorTemp = culori.parse(str);
  return !!colorTemp;
};
var isColor_default = isColor;

// src/utils/protocol.ts
import { URI } from "vscode-uri";
var RE_PATHSEP_WINDOWS = /\\/g;
function uriToPath(stringUri) {
  const uri = URI.parse(stringUri);
  if (uri.scheme !== "file") {
    return void 0;
  }
  return normalizeFsPath(uri.fsPath);
}
function normalizeFsPath(fsPath) {
  return fsPath.replace(RE_PATHSEP_WINDOWS, "/");
}

// src/utils/findAll.ts
function findAll(re, str) {
  let match;
  const matches = [];
  while ((match = re.exec(str)) !== null) {
    matches.push({ ...match });
  }
  return matches;
}

// src/utils/indexToPosition.ts
import lineColumn from "line-column";
function indexToPosition(str, index) {
  const data = lineColumn(str + "\n", index);
  if (!data) {
    return { line: 0, character: 0 };
  }
  const { line, col } = data;
  return { line: line - 1, character: col - 1 };
}

// src/utils/getCurrentWord.ts
function getCurrentWord(document, offset) {
  let left = offset - 1;
  let right = offset + 1;
  const text = document.getText();
  while (left >= 0 && ' 	\n\r":{[()]},*>+'.indexOf(text.charAt(left)) === -1) {
    left--;
  }
  while (right <= text.length && ' 	\n\r":{[()]},*>+'.indexOf(text.charAt(right)) === -1) {
    right++;
  }
  return text.substring(left, right);
}

// src/utils/isInFunctionExpression.ts
function isInFunctionExpression(word) {
  if (word.length < 1) {
    return false;
  }
  return "(" === word.charAt(0);
}

// src/CSSVariableManager.ts
import { Range, Position } from "vscode-languageserver/node";
import * as fs from "fs";
import fastGlob from "fast-glob";
import * as culori3 from "culori";
import axios from "axios";
import postcss from "postcss";
import { pathToFileURL } from "url";
import path from "path";
import postcssSCSS from "postcss-scss";
import postcssLESS from "postcss-less";

// src/CacheManager.ts
var CacheManager = class {
  constructor() {
    this.cachedVariables = /* @__PURE__ */ new Map();
    this.allVariables = /* @__PURE__ */ new Map();
  }
  get(key, filePath) {
    var _a, _b;
    if (filePath) {
      return (_a = this.cachedVariables[filePath]) == null ? void 0 : _a.get(key);
    }
    return (_b = this.allVariables) == null ? void 0 : _b.get(key);
  }
  getAll() {
    return this.allVariables;
  }
  set(filePath, key, value) {
    var _a;
    if (!this.cachedVariables[filePath]) {
      this.cachedVariables[filePath] = /* @__PURE__ */ new Map();
    }
    (_a = this.allVariables) == null ? void 0 : _a.set(key, value);
    this.cachedVariables[filePath].set(key, value);
  }
  clearFileCache(filePath) {
    var _a, _b;
    (_a = this.cachedVariables[filePath]) == null ? void 0 : _a.forEach((_, key) => {
      var _a2;
      (_a2 = this.allVariables) == null ? void 0 : _a2.delete(key);
    });
    (_b = this.cachedVariables[filePath]) == null ? void 0 : _b.clear();
  }
  clearAllCache() {
    var _a;
    (_a = this.allVariables) == null ? void 0 : _a.clear();
    this.cachedVariables.clear();
  }
};

// src/utils/culoriColorToVscodeColor.ts
import * as culori2 from "culori";
function culoriColorToVscodeColor(color) {
  const toRgb = culori2.converter("rgb");
  const rgb = toRgb(color);
  return { red: rgb.r, green: rgb.g, blue: rgb.b, alpha: rgb.alpha ?? 1 };
}

// src/CSSVariableManager.ts
var defaultSettings = {
  lookupFiles: ["**/*.less", "**/*.scss", "**/*.sass", "**/*.css"],
  blacklistFolders: [
    "**/.cache",
    "**/.DS_Store",
    "**/.git",
    "**/.hg",
    "**/.next",
    "**/.svn",
    "**/bower_components",
    "**/CVS",
    "**/dist",
    "**/node_modules",
    "**/tests",
    "**/tmp"
  ]
};
var getAST = (filePath, content) => {
  const fileExtension = path.extname(filePath);
  if (fileExtension === ".less") {
    return postcssLESS.parse(content);
  }
  if (fileExtension === ".scss") {
    return postcssSCSS.parse(content);
  }
  return postcss.parse(content);
};
var CSSVariableManager = class {
  constructor() {
    this.cacheManager = new CacheManager();
    this.parseCSSVariablesFromText = async ({
      content,
      filePath
    }) => {
      try {
        this.cacheManager.clearFileCache(filePath);
        const ast = getAST(filePath, content);
        const fileURI = pathToFileURL(filePath).toString();
        const importUrls = [];
        ast.walkAtRules((atRule) => {
          if (atRule.name === "import") {
            const match = atRule.params.match(
              /['"](?<protocol>http|https):\/\/(?<url>.*?)['"]/
            );
            if (match) {
              const url = `${match.groups.protocol}://${match.groups.url}`;
              importUrls.push(url);
            }
          }
        });
        await Promise.all(
          importUrls.map(async (url) => {
            try {
              const response = await axios(url, {
                responseType: "text"
              });
              const cssText = await response.data;
              return this.parseCSSVariablesFromText({
                content: cssText,
                filePath: url
              });
            } catch (err) {
              console.log(err, `cannot fetch data from ${url}`);
            }
          })
        );
        ast.walkDecls((decl) => {
          if (decl.prop.startsWith("--")) {
            const variable = {
              symbol: {
                name: decl.prop,
                value: decl.value
              },
              definition: {
                uri: fileURI,
                range: Range.create(
                  Position.create(
                    decl.source.start.line - 1,
                    decl.source.start.column - 1
                  ),
                  Position.create(
                    decl.source.end.line - 1,
                    decl.source.end.column - 1
                  )
                )
              }
            };
            const culoriColor = culori3.parse(decl.value);
            if (culoriColor) {
              variable.color = culoriColorToVscodeColor(culoriColor);
            }
            this.cacheManager.set(filePath, decl.prop, variable);
          }
        });
      } catch (error) {
        console.error(filePath);
      }
    };
    this.parseAndSyncVariables = async (workspaceFolders, settings = defaultSettings) => {
      for (const folderPath of workspaceFolders) {
        await fastGlob(settings.lookupFiles, {
          onlyFiles: true,
          cwd: folderPath,
          ignore: settings.blacklistFolders,
          absolute: true
        }).then((files) => {
          return Promise.all(
            files.map((filePath) => {
              const content = fs.readFileSync(filePath, "utf8");
              return this.parseCSSVariablesFromText({
                content,
                filePath
              });
            })
          );
        });
      }
    };
  }
  getAll() {
    return this.cacheManager.getAll();
  }
  clearFileCache(filePath) {
    this.cacheManager.clearFileCache(filePath);
  }
  clearAllCache() {
    this.cacheManager.clearAllCache();
  }
};

// src/index.ts
import { formatHex } from "culori";
var connection = createConnection(ProposedFeatures.all);
var documents = new TextDocuments(TextDocument);
var hasConfigurationCapability = false;
var hasWorkspaceFolderCapability = false;
var hasDiagnosticRelatedInformationCapability = false;
var cssVariableManager = new CSSVariableManager();
connection.onInitialize(async (params) => {
  const capabilities = params.capabilities;
  hasConfigurationCapability = !!(capabilities.workspace && !!capabilities.workspace.configuration);
  hasWorkspaceFolderCapability = !!(capabilities.workspace && !!capabilities.workspace.workspaceFolders);
  hasDiagnosticRelatedInformationCapability = !!(capabilities.textDocument && capabilities.textDocument.publishDiagnostics && capabilities.textDocument.publishDiagnostics.relatedInformation);
  const result = {
    capabilities: {
      textDocumentSync: TextDocumentSyncKind.Incremental,
      completionProvider: {
        resolveProvider: true
      },
      definitionProvider: true,
      hoverProvider: true,
      colorProvider: true
    }
  };
  if (hasWorkspaceFolderCapability) {
    result.capabilities.workspace = {
      workspaceFolders: {
        supported: true
      }
    };
  }
  return result;
});
connection.onInitialized(async () => {
  if (hasConfigurationCapability) {
    connection.client.register(
      DidChangeConfigurationNotification.type,
      void 0
    );
  }
  if (hasWorkspaceFolderCapability) {
    connection.workspace.onDidChangeWorkspaceFolders((_event) => {
      connection.console.log("Workspace folder change event received.");
    });
  }
  const workspaceFolders = await connection.workspace.getWorkspaceFolders();
  const validFolders = workspaceFolders == null ? void 0 : workspaceFolders.map((folder) => uriToPath(folder.uri) || "").filter((path2) => !!path2);
  const settings = await getDocumentSettings();
  cssVariableManager.parseAndSyncVariables(validFolders || [], settings);
});
var globalSettings = defaultSettings;
var documentSettings = /* @__PURE__ */ new Map();
connection.onDidChangeConfiguration(async (change) => {
  var _a;
  if (hasConfigurationCapability) {
    documentSettings.clear();
    cssVariableManager.clearAllCache();
    const validFolders = await connection.workspace.getWorkspaceFolders().then(
      (folders) => folders == null ? void 0 : folders.map((folder) => uriToPath(folder.uri) || "").filter((path2) => !!path2)
    );
    const settings = await getDocumentSettings();
    cssVariableManager.parseAndSyncVariables(validFolders || [], settings);
  } else {
    globalSettings = ((_a = change.settings) == null ? void 0 : _a.cssVariables) || defaultSettings;
  }
});
function getDocumentSettings() {
  const resource = "all";
  if (!hasConfigurationCapability) {
    return Promise.resolve(globalSettings);
  }
  let result = documentSettings.get(resource);
  if (!result) {
    result = connection.workspace.getConfiguration("cssVariables");
    documentSettings.set(resource, result);
  }
  return result;
}
documents.onDidClose((e) => {
  connection.console.log("Closed: " + e.document.uri);
  documentSettings.delete(e.document.uri);
});
connection.onDidChangeWatchedFiles((_change) => {
  _change.changes.forEach((change) => {
    const filePath = uriToPath(change.uri);
    if (filePath) {
      if (change.type === FileChangeType.Deleted) {
        cssVariableManager.clearFileCache(filePath);
      } else {
        const content = fs2.readFileSync(filePath, "utf8");
        cssVariableManager.parseCSSVariablesFromText({
          content,
          filePath
        });
      }
    }
  });
});
connection.onCompletion(
  (_textDocumentPosition) => {
    const doc = documents.get(_textDocumentPosition.textDocument.uri);
    if (!doc) {
      return [];
    }
    const offset = doc.offsetAt(_textDocumentPosition.position);
    const currentWord = getCurrentWord(doc, offset);
    const isFunctionCall = isInFunctionExpression(currentWord);
    const items = [];
    cssVariableManager.getAll().forEach((variable) => {
      const varSymbol = variable.symbol;
      const insertText = isFunctionCall ? varSymbol.name : `var(${varSymbol.name})`;
      const completion = {
        label: varSymbol.name,
        detail: varSymbol.value,
        documentation: varSymbol.value,
        insertText,
        kind: isColor_default(varSymbol.value) ? CompletionItemKind.Color : CompletionItemKind.Variable,
        sortText: "z"
      };
      if (isColor_default(varSymbol.value)) {
        completion.documentation = formatHex(varSymbol.value);
      }
      if (isFunctionCall) {
        completion.detail = varSymbol.value;
      }
      items.push(completion);
    });
    return items;
  }
);
connection.onCompletionResolve((item) => {
  return item;
});
connection.onDocumentColor((params) => {
  const document = documents.get(params.textDocument.uri);
  if (!document) {
    return [];
  }
  const colors = [];
  const text = document.getText();
  const matches = findAll(/var\((?<varName>--[a-z-0-9]+)/g, text);
  const globalStart = { line: 0, character: 0 };
  matches.map((match) => {
    const start = indexToPosition(text, match.index + 4);
    const end = indexToPosition(text, match.index + match[0].length);
    const cssVariable = cssVariableManager.getAll().get(match.groups.varName);
    if (cssVariable == null ? void 0 : cssVariable.color) {
      const range = {
        start: {
          line: globalStart.line + start.line,
          character: (end.line === 0 ? globalStart.character : 0) + start.character
        },
        end: {
          line: globalStart.line + end.line,
          character: (end.line === 0 ? globalStart.character : 0) + end.character
        }
      };
      colors.push({
        color: cssVariable.color,
        range
      });
    }
  });
  return colors;
});
connection.onHover((params) => {
  const doc = documents.get(params.textDocument.uri);
  if (!doc) {
    return null;
  }
  const offset = doc.offsetAt(params.position);
  const currentWord = getCurrentWord(doc, offset);
  if (!currentWord)
    return null;
  const nornalizedWord = currentWord.slice(1);
  const cssVariable = cssVariableManager.getAll().get(nornalizedWord);
  if (cssVariable) {
    return {
      contents: cssVariable.symbol.value
    };
  }
  return null;
});
connection.onColorPresentation((params) => {
  const document = documents.get(params.textDocument.uri);
  const className = document.getText(params.range);
  if (!className) {
    return [];
  }
  return [];
});
connection.onDefinition((params) => {
  const doc = documents.get(params.textDocument.uri);
  if (!doc) {
    return null;
  }
  const offset = doc.offsetAt(params.position);
  const currentWord = getCurrentWord(doc, offset);
  if (!currentWord)
    return null;
  const nornalizedWord = currentWord.slice(1);
  const cssVariable = cssVariableManager.getAll().get(nornalizedWord);
  if (cssVariable) {
    return cssVariable.definition;
  }
  return null;
});
documents.listen(connection);
connection.listen();
